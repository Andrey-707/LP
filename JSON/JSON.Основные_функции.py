# JSON.Основные_функции

# В отличие от csv, данные в этом формате не просто разделены запятыми, а имеют структуру
# ключ-значение. Это напоминает словарь Python, но в отличие от словаря, ключи в json
# могут быть только строками, заключенными в двойные кавычки.
{
  "key_1": "value",
  "key_2": "value 2"
}
# Значениями в json могут быть не только строками. Это могут быть числа, списки значений,
# а также вложенные объекты
{
  "key_1": [1, 2, 3, "value"],
  "key_2": {
    "inner_key": "inner value",
    "inner_key_2": ["a", "b", "c"],
    "inner_key_n": [
      {
        "key_1": "value"
      } 
    ]
  }
}
# Списки значений, как видно из примера, напоминают списки Python. Они ограничены
# квадратными скобками, а значения списка пишутся через запятую.

# Вложенность данных может быть бесконечной. То есть, значением ключа может быть список,
# а элементом этого списка — объект. В примере значение ключа key_2 — объект, в котором
# есть ключ inner_key_n со значением, которое является списком. Единственный элемент этого
# списка — снова объект.

# Переносы строк и отступы в этом формате необязательны. Они нужны только для удобства
# чтения. 
{
  "key_1": "value",
  "key_2": "value 2"
}

# Сериализация и десериализация json
# Преобразование переменных программы (словарей, списков) в формат для хранения называется
# «сериализацией», а обратное преобразование — «десериализацией».

# Для сериализации и десериализации в формат json в Python есть модуль, который так и
# называется — json. JSON — текстовый формат, поэтому сериализация в него — это по сути
# преобразование в строку и обратно.

# Для сериализации используется функция dumps из модуля json. Для того, чтобы сериализовать
# данные с ее помощью, достаточно передать в нее аргументом любую переменную. Запустите
# программу и посмотрите, что она выведет на экран.
import json

fake_dict = {
    "key_1": 1,
    "key_2": "any string"
}

s = json.dumps(fake_dict)
print(type(s), s)
# Вывод:
'''
<class 'str'> {"key_1": 1, "key_2": "any string"}
'''

# Для десериализации нужно использовать функцию loads. Ее аргумент — это строка с данными
# в формате json.
import json

json_data = '{"key_1": 1, "key_2": "any string"}'
fake_dict = json.loads(json_data)
print(type(fake_dict), fake_dict)
# Вывод:
'''
<class 'dict'> {'key_1': 1, 'key_2': 'any string'}
'''

# Значение ключа "key_1" в примере написано без кавычек и модуль json автоматически
# преобразует его в целое число:
import json

json_data = '{"key_1": 1, "key_2": [1, 2, 3]}'
fake_dict = json.loads(json_data)
print(type(fake_dict["key_1"]), fake_dict["key_1"])
# Вывод:
'''
<class 'int'> 1
'''
# Если значением ключа будет какая‑нибудь вложенная структура, например список,
# преобразование также произойдет автоматически
import json

json_data = '{"key_1": 1, "key_2": [1, 2, 3]}'
fake_dict = json.loads(json_data)
print(type(fake_dict["key_2"]), fake_dict["key_2"])
# Вывод:
'''
<class 'list'> [1, 2, 3]
'''

# Такая автоматическая работа с типами данных выгодно отличает json от csv. Там таких
# автоматических преобразований нет и все что мы получаем — это строки, разбитые на части.

# Каждая буква из строки «Любая строка» будет заменена на ее код. 
import json

fake_dict = {
    "key": "Любая строка"
}
s = json.dumps(fake_dict)
print(s)
# Вывод:
'''
{"key": "\u041b\u044e\u0431\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430"}
'''

# Обратное преобразование из строки в словарь вернет закодированное значение в
# первоначальный вид
import json

fake_dict = {
    "key": "Любая строка"
}
s = json.dumps(fake_dict)
print(s)
result = json.loads(s)
print(result)
# Вывод:
'''
{"key": "\u041b\u044e\u0431\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430"}
{"key": "Любая строка""}
'''

# С помощью необязательного аргумента ensure_ascii функции dumps можно отказаться от
# такого кодирования
import json

fake_dict = {
    "key": "Любая строка"
}
s = json.dumps(fake_dict, ensure_ascii=False)
print(s)
result = json.loads(s)
print(result)
# Вывод:
'''
{"key": "Любая строка"}
{"key": "Любая строка""}
'''
